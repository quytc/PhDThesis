%\chapter{Summaries of Papers}
\chapter{Summary of Contributions}

In this chapter, we give a short overview of our three peer-reviewed papers. We
will explain the problem addressed by each paper and its main contributions.
\		   

Automated verification of programs that manipulate complex dynamic linked data structures is a challenging problem in software verification. The problem becomes even more challenging when program correctness depends on relationships between data values that are stored in the dynamically allocated structures. 

In this paper, we present a general framework for verifying these programs. The underlying formalism of our framework is that
of forest automata (FA) which
has previously been developed for representing sets of reachable configurations of programs with complex dynamic linked data structures without data stored in nodes. In the FA framework, a heap
graph is represented as a composition of tree components. Sets of heap graphs can then
be represented by tuples of tree automata (TA). We extend FA by adding constraints between data elements associated with nodes of the heaps represented by FA, and we present extended versions of all operations needed for using the extended FA in a fully-automated verification approach, based on abstract interpretation.  
Technically, we express relationships between data elements associated with nodes of the heap graph by two classes of constraints. Local data constraints are associated with transitions of TA and capture relationships between data of neighbouring nodes in a heap graph; they
can be used, e.g., to represent ordering internal to some structure such as a binary search
tree. Global data constraints are associated with states of TA and capture relationships
between data in distant parts of the heap. In order to obtain a powerful analysis based on
such extended FA, the entire analysis machinery must have been redesigned, including
a need to develop mechanisms for propagating data constraints through FA, to develop a new inclusion check between
extended FAs, and to define extended abstract transformers

The resulting method allows for verification of pointer programs where the needed inductive invariants combine complex shape properties with constraints over stored data, such as sortedness. The method is fully automatic, quite general, and its efficiency is comparable with other state-of-theart analyses even though they handle less general classes of programs and/or are less automated. 







We have implemented our approach as an extension of the Forester tool and successfully applied it to a number of programs dealing with data structures such as various forms of singly- and doubly-linked lists, binary search trees, as well as skip lists. We presented experimental results from verifying programs dealing with variants of (ordered) lists and trees. To the best of our knowledge, our method is the first one to cope fully automatically with a full C implementation of a 3-level skip list. 

\section{Paper II: Automated Verification of Linearization Policies} 
Data structures that can be accessed concurrently by many parallel threads are a central component of many software applications, and are implemented in several widely used libraries (e.g., java.util.concurrent). Linearizabilityis the standard correctness criterion for such concurrent data structure implementations. It states that each operation on the data structure can be considered as being performed atom





rating operations announcing the occurrence of
LPs during each method invocation. The controller is occasionally activated, either by
its thread or by another controller, and mediates the interaction of the thread with the
observer as well as with other threads. Secondly, we handle the challenge of an unbounded number of threads by extending the successful thread-modular approach which verifies a concurrent program by generating an invariant that correlates the global state with the local state of an arbitrary thread. Finally,  we present a novel symbolic representation of singly-linked heap structures.
We have implemented our technique in a tool, and applied it to specify and automatically verify linearizability of all the implementations of concurrent set, queue,
and stack algorithms known to us in the literature, as well as some algorithms for implementing atomic memory read/write operations. To use the tool, the user needs to
provide the code of the algorithm together with the controllers that specify linearization
policies. To our knowledge, this is the first time all these examples are verified fully
automatically in the same framework.
\section{Paper III: Fragment Abstraction for Concurrent Shape Analysis}  
A major challenge in automated verification is to develop techniques
that are able to reason about fine-grained concurrent algorithms that consist of
an unbounded number of concurrent threads, which operate on an unbounded
domain of data values, and use unbounded dynamically allocated memory. Existing automated techniques consider the case where shared data is organized into
singly-linked lists.

In this paper, we present a technique for automatic verification of concurrent data structure implementations that operate on dynamically allocated heap structures which are more complex than just singly-linked lists. Our approach is the first
framework that can automatically verify concurrent data structure implementations that
employ singly linked lists, skiplists [15, 23, 39], as well as arrays of singly linked
lists [11], at the same time as handling an unbounded number of concurrent threads,
an unbounded domain of data values (including timestamps), and an unbounded shared
heap.

Our technique is based on a novel shape abstraction, called fragment abstraction,
which in a simple and uniform way is able to represent several different classes of
unbounded heap structures. Its main idea is to represent a set of heap states by a set
of fragments. A fragment represents two heap cells that are connected by a pointer
field. For each of its cells, the fragment represents the contents of its non-pointer fields,
together with information about how the cell can be reached from the program’s pointer
variables. The latter information consists of both: (i) local information, saying which
pointer variables point directly to them, and (ii) global information, saying how the cell
can reach to and be reached from (by following chains of pointers) other heap cells that
are significant from a global perspective, typically since they are pointed to by global
variables. A set of fragments represents the set of heap states in which any two pointerconnected nodes is represented by some fragment in the set. Thus, a set of fragments
describes the set of heaps that can be formed by “pieced together” fragments in the
set. The combination of local and global information in fragments supports precise
reasoning about the sequence of cells that can be accessed by threads that traverse the
heap by following pointer fields in cells and pointer variables: the local information
captures properties of the cell fields that can be accessed as a thread dereferences a
pointer variable or a pointer field; the global information also captures whether certain
significant accesses will at all be possible by following a sequence of pointer fields. This
support for reasoning about patterns of cell accesses enables automated verification of
reachability and other functional properties.
Fragment abstraction can (and should) be combined, in a natural way, with data abstractions for handling unbounded data domains and with thread abstractions for handling an unbounded number of threads. For the latter we adapt the successful threadmodular approach [5], which represents the local state of a single, but arbitrary thread,
together with the part of the global state and heap that is accessible to that thread. Our
combination of fragment abstraction, thread abstraction, and data abstraction results in
a finite abstract domain, thereby guaranteeing termination of our analysis.
We have implemented our approach and applied it to automatically verify correctness, in the sense of linearizability, of a large number of concurrent data structure
algorithms, described in a C-like language. More specifically, we have automatically
verified linearizability of most linearizable concurrent implementations of sets, stacks,
and queues, and priority queues, which emply singly-linked lists, skiplists, or arrays
of timestamped singly-linked lists, which are known to us in the literature on concurrent data structures. For this verification, we specify linearizability using the simple and
powerful technique of observers [1, 7, 21, 3], which reduces the criterion of linearizability to a simple reachability property. To verify implementations of stacks and queues,
the application of observers can be done completely automatically without any manual
steps, whereas for implementations of sets, the verification relies on light-weight user
annotation of how linearization points are placed in each method. 

\section{Related Work}
This chapter reviews related work, along the main topics of this thesis including: verification of linearizabilities of concurrent algorithms, 
sequential shape analysis and concurrent techniques.
\subsection{Linearizabilities}
Much previous work has been devoted to
the {\it manual} verification of linearizability for
concurrent programs such as \cite{Aaron:locigcal:linearizability}.
In \cite{OHearnlist}, O'Hearn {\it et al.}  define a
{\it hindsight lemma} that
provides a non-constructive evidence for linearizability. 
%
The lemma is used to prove linearizability of an optimistic variant of 
the lazy set algorithm.
%% by identifying the hindsight property of the algorithm. 
Vafeiadis \cite{Vafeiadis:Thesis}
uses forward and backward simulation relations together
with history or prophecy variables to prove linearizability.
%
These approaches are manual, and without
tool implementations.
{\it Mechanical} proofs of linearizability, using interactive theorem
provers, have been reported in 
\cite{Colvin:Lazy-List,Derrick:fm14,SWD:cav12,SDW:tcl14}.
%
For instance, Colvin {\it et al.} \cite{Colvin:Lazy-List}
verify the lazy set algorithm in  PVS,
using a combination of forward and backward simulations.

There are several works on {\it automatic} verification of linearizability.
%
In \cite{Vafeiadis:cav10}, Vafeiadis
develops an automatic tool for proving  linearizability that
employs instrumentation to verify logically pure executions.
%
However, this work can handle non-fixed LPs only for read-only methods,
i.e, methods that do not modify the heap.
%
This means that the method cannot handle
 algorithms like the {\it Elimination} queue ~\cite{Shavit:ElimQueue}, {\it HSY} stack~\cite{HSYstack}, {\it CCAS}~\cite{Harris:CAS}, 
{\it RDCSS}~\cite{Harris:CAS} and {\it HM} set~\cite{ArtOfMpP} that we consider in this paper. In addition, their shape abstraction is not powerful enough to handle algorithms like {\it Harris} set~\cite{Harris:list} and {\it Michael} set~\cite{Michael:list} that are also handled by our method.
%
%For instance, in the {\it HSY} stack algorithm both
%the {\tt push} and {\tt pop} operations modify
%the heap and help each other~\cite{HSYstack}. 
%
Chakraborty {\it et al.} \cite{HSV:concur13}
describe an ``aspect-oriented'' method for  modular verification 
of concurrent queues that they use to prove linearizability of the Herlihy/Wing queue.
Bouajjani et al. \cite{BEEH:icalp15} extended this work to show that verifying 
linearizability for certain
fixed abstract data types, including queues and stacks, is reducible to 
control-state reachability. 
%
We can incorporate this technique into
our framework by a suitable construction of observers.
The method can not be applied to sets.
%
The most recent work of Zhu {\it et al.} \cite{Poling}
describe a tool that is applied for specific set, queue, and stack  
algorithms. For queue algorithms, their technique can handle queues with helping mechanism except for {\it HW} queue~\cite{HeWi:linearizability} which is handled by our paper.
%
For set algorithms, the authors can only handle those that perform an optimistic contains (or lookup) operation by applying the {\it hindsight lemma} from 
\cite{OHearnlist}. 
%
Hindsight-based proofs provide only {\it non-constructive} 
evidence of linearizability. Algorithms with non-optimistic contains (or lookup) operation like {\it HM}~\cite{ArtOfMpP}, {\it Harris}~\cite{Harris:list} and {\it Michael}~\cite{Michael:list} sets cannot be verified by their technique.  
%
Vechev {\it et al.}~\cite{Vechev:spin09}
check linearizability with user-specified non-fixed LPs,
using a tool for finite-state verification.
Their method assumes a bounded number of threads, and
they report state space explosion when having more than two threads.
%
Dragoi  {\it et al.} \cite{Henzinger:CAV13} describe a method for proving
linearizability that is applicable to algorithms with non-fixed LPs.
%
However, their method needs to rewrite the implementation so that all operations 
have linearization points within the rewritten code.
%
\v{C}ern{\'y} {\it et al} \cite{CernyRZCA:CAV10} show decidability of a class
of programs with a bounded number of threads operating on concurrent data structures.
%
%% This paper is about a different problem
%% Horn and Kroening \cite{Kroening-Linearizability:FORTE15}
%% have recently presented an efficient linearizability checker based on {\it P-compositionality} 
%% which can be applied when having a bounded number of threads.
%
Finally, the works~\cite{AHHR:integrated,BLMRS:cav08,Vafeiadis:vmcai09}
all require fixed linearization points.

We have not found any report in the literature of a
verification method that is sufficiently powerful to
automatically verify the class of concurrent set
implementations based on sorted and non-sorted
singly-linked lists having non-optimistic contains (or lookup) operations we consider. For instance %For instance,
%the shape abstraction of the CAVE implementation
%\cite{Vafeiadis:cav10}
%is not powerful enough to handle
the lock-free sets of {\it HM}~\cite{ArtOfMpP},
{\it Harris}~\cite{Harris:list}, or {\it Michael}~\cite{Michael:list},
or unordered set of~\cite{Zhang:unorderedlist},
%reported in
%Section~\ref{section:experiments} (as also confirmed by the CAVE
%tool implementors).
%The same applies to
%the tool in~\cite{Poling}.


\subsection{Shape Analysis}
\subsubsection{Sequential Shape Analysis}
Our approach builds on the fully automated FA-based
approach for shape analysis of programs with complex dynamic linked data
structures \cite{forester11,Forester}. We significantly extend this approach by
allowing it to track ordering relations between data values stored inside
dynamic linked data structures. 

For shape analysis, many other formalisms than FA have been used, including,
e.g., separation logic and various related graph formalisms
\cite{Hongseok:SL,thor10,rival11,Kamil:SL}, other logics \cite{SagivRW02,Jakob:ML},
automata \cite{artmc12}, or graph grammars \cite{Jonathan:Shape}. Compared with FA,
these approaches typically handle less general heap structures (often restricted
to various classes of lists) \cite{Hongseok:SL,Kamil:SL}, they are less
automated (requiring the user to specify loop invariants or at least inductive
definitions of the involved data structures)
\cite{thor10,rival11,Kamil:SL,Jonathan:Shape}, or less scalable \cite{artmc12}.

Verification of properties depending on the ordering of data stored in SLLs was
considered in~\cite{lists-counters}, which translates programs with SLLs to
counter automata. A subsequent analysis of these automata allows one to prove
memory safety, sortedness, and termination for the original programs. The work
is, however, strongly limited to SLLs. In this paper, we get inspired by the way
that \cite{lists-counters} uses for dealing with ordering relations on data, but
we significantly redesign it to be able to track not only ordering between
simple list segments but rather general heap shapes described by FA. In order to
achieve this, we had to not only propose a suitable way of combining ordering
relations with FA, but we also had to significantly modify many of the
operations used over FA.

In~\cite{atva09}, another approach for verifying data-dependent properties of
programs with lists was proposed. However, even this approach is strongly
limited to SLLs, and it is also much less efficient than our current approach.
In~\cite{AHHR:integrated:rep}, concurrent programs operating on SLLs are analyzed
using an adaptation of a transitive closure logic~\cite{BiRa:vmcai06}, which
also tracks simple sortedness properties between data elements.

Verification of properties of programs depending on the data stored in dynamic
linked data structures was considered in the context of the TVLA tool
\cite{Loginov:AbstrRefViaInductLearning:05} as well. Unlike our approach,
\cite{Loginov:AbstrRefViaInductLearning:05} assumes a fixed set of shape
predicates and uses inductive logic programming to learn predicates needed for
tracking non-pointer data. The experiments presented in
\cite{Loginov:AbstrRefViaInductLearning:05} involve verification of sorting and
stability properties of several programs on SLLs (merging, reversal,
bubble-sort, insert-sort) as well as insertion and deletion in BSTs. We do not
handle stability, but for the other properties, our approach is much faster.
Moreover, for BSTs, we verify that a node is greater/smaller than all the nodes
in its left/right subtrees (not just than the immediate successors as in
\cite{Loginov:AbstrRefViaInductLearning:05}).

An approach based on separation logic extended with constraints on the data
stored inside dynamic linked data structures and capable of handling size,
ordering, as well as bag properties was presented in \cite{sleek12}. Using the
approach, various programs with SLLs, DLLs, and also AVL trees and red-black
trees were verified. The approach, however, requires the user to manually
provide inductive shape predicates as well as loop invariants.  Later, the need
to provide loop invariants was avoided in \cite{sleek13}, but a need to manually
provide inductive shape predicates remains.

Another work that targets verification of programs with dynamic linked data
structures, including properties depending on the data stored in them, is
\cite{Zee:pldi08}. It generates verification conditions in an undecidable
fragment of higher-order logic and discharges them using decision procedures,
first-order theorem proving, and interactive theorem proving. To generate the
verification conditions, loop invariants are needed. These can either be
provided manually or sometimes synthesized semi-automatically using the approach
of \cite{wies07hav}. The latter approach was successfully applied to several
programs with SLLs, DLLs, trees, trees with parent pointers, and 2-level skip
lists. However, for some of them, the user still had to provide some of the
needed abstraction predicates.
Several works, including~\cite{dragoi:atva12}, define frameworks for reasoning
about pre- and post-conditions of programs with SLLs and data. Decidable
fragments, which can express more complex properties on data than we consider,
are identified, but the approach does not perform fully automated verification,
only checking of pre-post condition pairs.


\subsubsection{Concurrent Shape Analysis}
A large number of techniques have been developed for representing heap structures
in automated analysis, including,
e.g., separation logic and various related graph formalisms
\cite{InvaderCAV08,rival11,dudka13}, other logics \cite{SRW:threevalued},
automata \cite{boxes13}, or graph grammars \cite{Jonathan:Shape}. 
Most works apply these to sequential programs.

Approaches for automated verification of concurrent algorithms are limited to the
case of singly-linked
lists~\cite{AHHR:integrated:short,meyer:vmcai16,Quy:sas16,Sagiv:correlation,Vafeiadis:cav10}.
Furthermore, many of these techniques impose additional restrictions on the considered verification problem, such as bounding the number of accessing
threads~\cite{Amit:comparisonAbstraction,Vechev:spin09,CernyRZCA:CAV10}.

In~\cite{AHHR:integrated:short}, concurrent programs operating on SLLs are analyzed
using an adaptation of a transitive closure logic~\cite{BiRa:vmcai06}, combined with
tracking of simple sortedness properties between data elements; the approach does
not allow to represent patterns observed by threads when following sequences of
pointers inside the heap, and so has not been applied to concurrent set
implementations.
In our recent work~\cite{Quy:sas16}, we extended this approach to handle SLL implementations
of concurrent sets by adapting a
well-known abstraction of singly-linked lists ~\cite{MYRS:Canonical} for concurrent programs.
The resulting technique is specifically tailored for singly-links.
Our fragment abstraction is significantly simpler conceptually, and can therefore be  adapted
also for other classes of heap structures.
The approach of~\cite{Quy:sas16} is the only one with a shape representation strong enough to
verify  concurrent set
implementations based on sorted and non-sorted
singly-linked lists having non-optimistic contains (or lookup) operations we consider, such as
the lock-free sets of {\it HM}~\cite{ArtOfMpP},
{\it Harris}~\cite{Harris:list}, or {\it Michael}~\cite{Michael:list},
or unordered set of~\cite{Zhang:unorderedlist}. As shown in
Section~\ref{section:experiments}, our fragment abstraction can handle them
as well as also algorithms employing skiplists and arrays of singly-linked lists.

There is no previous work on automated verification of skiplist-based concurrent algorithms.
Verification of {\em  sequential} algorithms have been addressed under restrictions, such as limiting the
number of levels to two or three~\cite{boxes13,Quy:atva13:journal}. The work~\cite{Sanchez:skiplists}
generates verification conditions for statements in sequential skiplist implementations. All these
works assume that skiplists have the well-formedness property that any higher-level lists is a
sublist of any lower-level list, which is true for sequential skiplist algorithms, but false for
several concurrent ones, such as~\cite{ArtOfMpP,Linden:opodis13}.



Concurrent algorithms based on arrays of SLLs, and including timestamps, e.g.,
for verifying the algorithms in~\cite{ts-stack} have shown to be rather challenging. Only
recently has the TS stack been verified by non-automated
techniques~\cite{BEEM:cav17} using a non-trivial extension of
forward simulation, and the TS queue been verified manually by a new technique
based on partial orders~\cite{Khyzha:esop17,singh:issre16}..
We have verified both these algorithms automatically using fragment abstraction,

Our fragment abstraction is related in spirit to other formalisms that
abstract dynamic graph structures by defining some form of equivalence on
its nodes (e.g.,~\cite{spotlight07,SRW:threevalued,boxes13}). These have
been applied to verify functional correctness fine-grained concurrent
algorithms for a limited number of SLL-based algorithms. Fragment
abstraction's representation of both local and global information allows to
extend the applicability of this class of techniques.
%\newcommand{\contribitem}[1]{\tikz[baseline=(c.base)]\node(c)[paper]{\ref{paper:#1}};}
%
%\noindent%\vspace{1\baselineskip}%
%\begin{list}{%
%    Hey% Cheating
%  }{%
%    \raggedright%
%    \setlength{\leftmargin}{2,5em}%
%    \setlength{\labelsep}{1em}%
%    \setlength{\itemsep}{1em plus 0.2em minus 0.2em}%
%    \setlength{\parsep}{0mm}%
%    \setlength{\topsep}{0mm}}%
%
%\item[\contribitem{ATVA13}] %
%  I designed the method with \lukas. %
%  I am the sole implementer of the prototype and responsible for the experimentation. %
%  I participated in all parts of the writing, equally as my co-authors. %
%
%\item[\contribitem{SAS16}] %
%  I designed the method with \lukas\ and \ahmed. %
%  I am the sole implementer of the prototype and responsible for the experimentation. %
%  I participated in all parts of the writing, equally as my co-authors. %
%
%\item[\contribitem{SAS14}] %
%  I designed the method with \lukas. %
%  I am the sole implementer of the prototype and responsible for the experimentation. %
%  I participated in all parts of the writing, equally as my co-authors. %
%
%\end{list}\nopagebreak%
