%%% =============================================================
%\chapter*{Sammanfattning på Svenska \texorpdfstring{\hfill\raisebox{-2em}{\includegraphics[height=3em]{img/sverige.png}}}{}}
%\addcontentsline{toc}{section}{\texorpdfstring{\protect\raisebox{-0.5ex}{\protect\makebox[3ex]{\protect\includegraphics[height=1em]{img/flag-sverige.png}}}}{} in Swedish}
%\index{Summary!Sammanfattning \protect\makebox[3ex]{\protect\includegraphics[height=1em]{img/flag-sverige.png}}}
%
%Du har säkerligen använt en dator och varit väldigt nöjd, och detta
%för att den förenklade många långa och svåra %mödosamma
%uppgifter.
%%
%Ibland gör den dock inte som du vill: du klickar på knappen ``Gör
%det'', men den följer inte ditt kommando. Eller ännu värre, datorn
%hänger upp sig och svarar inte på något kommando alls.
%%
%Viktiga arbetstider har kanske gått till spillo.
%%
%Du tar ett djupt andetag, startar om datorn, och allting fungerar igen
%som det ska.
%%
%Felet verkar komma från \emph{programvaran} som styr datorn, inte från
%själva maskinen.
%%
%Du undrar varför detta fel inte redan korrigerats, och dessutom,
%varför det från början inte \emph{försäkrades} om att felet inte kunde
%inträffa.
%
%
%Termen \emph{buggar} används generellt för att beskriva alla typer av
%fel, vare sig felet finns i dem elektriska delarna av maskinen eller i
%programmeringen.
%%
%Med tanke på hur komplexa dagens datorer är, är det inte förvånande
%att de innehåller många buggar.
%%
%De behöver ju %faktiskt
%hantera en stor mängd parametrar och egenskaper som kan generera
%% ge plats till
%många olika möjliga beteenden.
%%
%Och vi nämner inte ens den mänskliga faktorn som inför fel under
%programmeringsfasen!
%%
%Därför finns det en trend att bygga datorer med flera mindre enheter,
%som då gör datorn enklare att hantera.
%%
%Men då ställs vi inför ett nytt problem: dessa enheter kan när som
%helst kommunicera med varandra.
%%
%På grund av denna oförutsägbarhet blir det väldigt svårt att ta hänsyn
%till alla scenarier.
%
%Företag som tillverkar programvara har inget intresse av att lämna
%buggar, eftersom ett fel någonstans kan orsaka en rad andra fel i
%efterhand. %kaskad
%%
%De inkluderar därför en viktig kvalitetskontroll under
%utvecklingsfasen: om det finns för många buggar blir det helt enkelt
%inte kostnadseffektivt eller ens möjligt att senare eliminera dem.
%%
%En del buggar är dock enklare att lösa än andra.
%%
%Det spelar faktiskt ingen större roll om man inte kan svara i
%telefonen när man får ett samtal, eller om texteditorn förlorar dem
%senaste dokumentsuppdateringarna.
%%
%Detta är väldigt tråkigt, men ingen fara på taket! Vi klarar oss och
%väntar bara på programuppdateringen som löser buggen.
%%
%Å andra sidan får inga fel inträffa för dem så-kallade %
%\emph{kritiska systemen}, vars säkerhet är viktig i allra högsta
%grad. Alla fel måste elimineras, antingen i programvaran eller i
%maskinvaran.
%%
%Det är oacceptabelt, till exempel, att en pacemaker slutar fungera när
%ägaren passerar säkerhetskontrollen på flygplatsen, att krockkudden
%inte utlöses snabbt nog vid en trafikolycka om radion är på, eller om
%två tåg kolliderar på grund av att signalsystemet inte fungerat.
%%
%Därför är det nödvändigt att utveckla metoder som upptäcker
%ett felaktigt beteende i sådana system.
%
%
%Den vanligaste metoden är \emph{testing}: man kör programmet med olika
%värden för varje variabel och kollar om funktionaliteten
%överensstämmer med det som förväntas.
%%
%Dessa testscenarier är genomtänkta för att beskriva ett maximalt antal
%beteenden.
%%
%När komplexiteten däremot ökar, kan programmet befinna sig i väldigt
%många olika tillstånd. Det börjar då bli svårt att \emph{garantera}
%att metoden täcker alla möjliga programkörningar.
%%
%Det är även rent av omöjligt om systemet innehåller en parameter vars
%värde exempelvis är en siffra.
%%
%Metoden är ett effektivt sätt att upptäcka enkla buggar snabbt, men
%subtila buggar, såsom dem som kommer från en oförutsägbar tajming,
%kvarstår obemärkta.
%%
%För dem kritiska systemen där säkerheten är ytterst viktig, är det
%otänkbart att använda en metod som eventuellt tar sig igenom alla
%tester, men fortfarande innehåller buggar.
%
%För att visa att ett program verkligen uppfyller vissa egenskaper,
%måste vi först komma överens om vad det ska överensstämma med
%---vilket formellt heter en \emph{specifikation}.
%%
%Genom att lista programkonfigurationerna som borde undvikas, eller som
%önskas, alternativt båda, så beskriver man dem två kategorierna av
%specifikationer: \emph{säkerhetsegenskaper} och
%\emph{livlighetsegenskaper} (Safety och Liveness på engelska).
%%
%Till exempel, ``pacemakern stannar aldrig'', ``krockkudden måste
%öppnas inom mindre än $x$~millisekonder'', eller ``ingen enstaka
%process blockerar övriga processer'' är säkerhetsegenskaper.
%%
%Vi måste se till att programmet aldrig befinner sig i en felaktig
%konfiguration.
%% 
%Till motsatsen, ``brevbäraren levererar till rätt mottagare'',
%``systemet gör framsteg'', eller ``servern hanterar en HTTP-förfråga''
%är livlighetsegenskaper, där man observerar rätta konfigurationer,
%förknippade med vissa sannolikheter.
%% 
%Det är upp till oss att definiera vad specifikationen ska innehålla, för
%att verifiera det som önskas.
%% 
%Om ett låsningsfritt bromssystem (ABS) % Antilock Braking System
%beräknar hur hårt bilens bromsning ska vara men gör detta för sent,
%bör systemet beträktas som felaktigt.
%% 
%Denna avhandling fokuserar på säkerhetsegenskaper.
%\begin{statement}
%  {\bf Säkerhet}: %
%  {\it Givet en specifikation, kan systemet hamna i en fel konfiguration?}
%\end{statement}
%
%%% ------------------------
%Snarare än att testa programmet i specifika scenarier eller att
%analysera källkoden, fokuserar vi i denna avhandling på \emph{formell
%  verifiering}, som är ett matematiskt ramverk, för att \emph{bevisa}
%att programmet uppfyller sina egenskaper.
%
%Dessutom vill vi bevisa det helt \emph{automatiskt}, det vill säga
%utan tillsyn av användaren.
%%
%Vi börjar genom att extrahera en modell som motsvarar det ursprungliga
%programmet. I samband med det borttar vi delarna som är irrelevanta
%för den egenskapen som verifieras.
%%
%Men vad händer när programmet manipulerar obegränsade variabler? Vi
%talar då om system med ett oändligt antal tillstånd, och vi behöver
%framställa en approximation som är i linje med själva programmet.
%%
%Målet är att utforma en metod som \emph{garanterar} att inget fel
%kvarstår, och som även ger svar inom en rimlig tid.
%
%Många system med ett oändligt antal tillstånd kan faktiskt
%karakteriseras av en familj som består av system med ett ändligt antal
%tillstånd, och en parameter (eller flera) med värde från en obegränsad
%domän.
%%
%För varje värde på parametern, innehåller systemet ett ändligt antal
%tillstånd.
%%
%Parametern kan exempelvis vara
%antalet processer som är aktiva i en viss session av ett protokoll, %
%antalet noder i ett nät, %
%eller hur komponenterna av ett program kommunicerar med varandra.
%%
%Hur som helst, system som innehåller en preliminärt okänd parameter
%bör ha ett korrekt beteende oavsett värdet på parametern. De betraktas
%därför som system med ett oändligt antal tillstånd och kallas för
%parametriserade system.
%I denna avhandling presenterar vi två metoder för att verifiera vissa
%säkerhetsegenskaper hos sådana parametriserade system.
%
%Den första metoden körs baklänges. Den startar från dem felaktiga
%tillstånden, och beräknar vilka andra tillstånd som skulle kunna leda
%till ett fel.
%%
%Med andra ord upptäcker metoden alla konfigurationer som direkt eller
%indirekt är felaktiga.
%%
%Om initialtillstånden av programmet inte tillhör dem sistnämnda, anses
%programmet vara korrekt. Vi måste såklart först se till att
%approximationen av modellen motsvarar det ursprungliga programmet.
%
%Den andra metoden startar från initialtillstånden. Den begränsar sig
%till små värden av parametern, och härleder ett tröskelvärde, efter
%vilket metoden inte behöver fortsätta: den har faktiskt all nödvändig
%information för att dra slutsatsen att det inte finns några
%felkonfigurationer för större värden på parametern över denna tröskel.
%% 
%För att förenkla, bryter metoden ner varje konfiguration i små bitar
%av en viss storlek, och rekombinerar bitarna på alla möjliga sätt,
%just för att skapa konfigurationer av större storlek (litegrann som
%Lego\-bitar). %tegelstenar
%% 
%Tanken är att samla alla dem små bitarna och se till att ingen
%rekombination matchar någon felaktig konfiguration.
%% 
%I så fall är tröskeln hittad. Annars börjar man om med lite större
%bitar.
%
%
%Slutligen är det intressant att undra vilka av villkoren som behövs
%för att metodens beräkningar inte ska fortsätta för evigt. Problemet
%klassas som oavgörbart, det vill säga att det inte finns någon
%generell metod som kan lösa \emph{alla} instanser av
%problemet. Däremot har dessa två metoder trots allt visat sig vara
%väldigt effektiva.
%%
%Där andra metoder tog timmar, kunde dessa två metoder faktiskt
%verifiera vissa program inom sekunder, vilket var målet.
%%
%I vissa fall kan man även ge garanti på att antalet beräkningar är
%begränsad.
%
