%% ====================================================================
\section{Data Independence}
\label{section:data:independence}
%% ====================================================================

We can notice that data structures such as stacks and queues are
merely containers and do not look at data: their execution does not
branch in some particular part of the code depending on the data
values. All data values are treated equally. %
%
% For instance, if $\dset=\nat$ and if the system accepts a~trace that,
% say, inputs the values 1,2,3 and outputs 3,2,1 (i.e.\ a stack), we can
% easily see that there is an equivalent trace that inputs the data
% values 4,5,6 and outputs 6,5,4 since the system can execute in the
% same way regardless of the data values that it manipulates.
For instance, if $\dset=\nat$ and if the system can input the values
1,2,3 and output 3,2,1 (i.e.\ a stack), we can easily see that there
is an equivalent behaviour where the system inputs the data values
6,5,4 and outputs 4,5,6. The system can execute in the same way
regardless of the data values that it manipulates.
%
Intuitively, data values do not matter, so we might as well rename
them. In that previous simple example, we could rename 6 into 1, 5
into 2, and 4 into 3. We would then have two equivalent traces.

\index{Traces}%
Even though we can rename the traces adequately, % judiciously
the set of all traces includes traces where input events can be
repeated using the same data value, and is therefore still potentially
infinite.
%
However, we can observe that it is possible for any trace to ``count''
the repeated input values and enumerate them while renaming them,
effectively creating a trace where the data values of input events are
all distinct. In such a case, we call the latter
a~\emph{differenciated trace}.
%
For example, if the system takes 1,2,3,1,2 as input, we could rename
the second 1 into 4 and the second 2 into 5. This creates an
equivalent trace where all the data values are distinct.

\begingroup%
\setlength\intextsep{1.25\baselineskip plus 3pt minus 2 pt}
\begin{figure}[ht]
  %\centering
  \tikzinput[\linewidth]{img/data-independence}
  \caption{Stack do not look at data}
  \label{figure:data:independence}
\end{figure}
\endgroup

\index{Data Independence}%
We can now introduce the desired definition: we say that a~set of
traces (or the program it characterizes) is \emph{data independent} if
and only if (i) it is closed under renaming and (ii) it can be
generated by a set of differentiated traces.
%
Detecting data-independence is easily done by syntactically checking
that data values are not compared and that uninitialized variables are
not used in the source code.
% These are straightforward extensions of [28].

If a data independent system accepts a bad trace, then it will also
accept a bad differentiated trace (and vice-versa).
%
In consequence, for a data independent program, to determine whether
the safety property is satisfied, it is sufficient to only consider
differentiated traces, i.e.\ executions in which any data value is
inserted at most once.
%
Furthermore, by adapting an argument from
Wolper~\cite{Wolper:dataindependence}, we can abstract away the data
values, by picking any two of them and flattening all the others
values to a third one.
%
In Figure~\ref{figure:data:independence}, the top part represents a
system which inputs a sequence of \emph{distinct} data values and
outputs them in reverse order, i.e\ a~stack.
%
In the bottom part, on the other hand, we abstract the data away and
choose \prgcode{blue} and \prgcode{red} to be the ``important'' values
while another ``neutral'' value \prgcode{white} is not.
%
If the bottom system is safe, so is the top one, and so is the system
in general (c.f.\ Paper~\ref{paper:TACAS13} for further details).
%
% The specification has been reduced to traces involving three abstract
% data values, where two of them are not repeated.
%
