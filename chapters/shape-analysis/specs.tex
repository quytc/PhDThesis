%% ====================================================================
\section*{Linearizability}      
\label{section:specification:concurrent:data:structure}     
\index{Specification}%         
%% ====================================================================
\begingroup%     
In a concurrent program, the methods of the different executing threads can overlap in time. Thus, a {\tt rmv} method that
executes in parallel with an {\tt add} method for the same key may or may not
find the element in the set, depending on how the individual method statements
overlap in time. For a user of the data structure, it is important to know precisely
what can happen when several methods access a data structure concurrently
without inspecting the code of each method. Such a user would want to have
a criterion for how operations take effect, which considers only the points in
time of method calls and returns. The most widely accepted such condition is
linearizability.  
%The program statements 
%in each method are totally ordered. Whereas, statements from different methods in different executing threads might form a partial order. This partial order raise the difficult of reasoning about program execution. One of the main correctness criterion of a concurrent program is linearizability, 
Linearizability defines consistency for the historyof call and response events generated by an execution of the program at hand \cite{HeWi:linearizability}. Intuitively, linearizability requires every method to take effectat some point ({\emph {linearization point}}) between it's call and return events. A linearization point is intuitively a moment where the effect of the method
becomes visible to other threads. An execution of a (concurrent) system is modeled by a (concurrent) history, which is a finite
sequence of method invocation and response events. A (concurrent) history is linearizable if and only if there is some order forthe effects of the actions that corresponds to a valid sequential history. The valid sequence history can be generated by an execution of the sequential specification object. A concurrent object is linearizable iff each of its historiesis linearizable.

\setlength\intextsep{\dazintextsep}
\begin{figure}[ht]
  \centering
  \tikzinput[\linewidth]{img/linearizability} 
  \caption{Linearizability, where the commit points are marked with \protect\commitpoint{}.}
  \label{figure:shape:linearizability}  
\end{figure}          
  

\index{Linearizability}%
Figure~\ref{figure:shape:linearizability} provides a examples of trace of methods of concurrent program implementing sets.
In the trace, each method takes effect
instantaneously at its (called the \emph{linearization point})
between call and return events~\cite{HeWi:linearizability}. When we order methods according to its linearization point, we get a total ordered sequence that respect the sequential specification of the set.
%A linearization point normally stays inside the code of the
%method.  However, in some cases, it it is located in
%the code of another method depending on the execution path.



\endgroup