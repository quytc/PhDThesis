%% ====================================================================
\chapter{Model Checking}
\label{section:model:checking}
\index{Model Checking}%
\index{Verification Methods!Model Checking}%
%% ====================================================================
%
% Within the field of formal verification, 
The approach that we focus on this thesis is
\emph{model-checking}.
%% ********************************************************************
\KW{Automation}%
\index{Automation}%
%% ********************************************************************
This method will try to verify whether a model of the program
satisfies its specification.
%
%It is often called a push-button technology.
%
 
This approach was introduced by Emerson and Clarke~\cite{CE82} and by
Queille and Sifakis~\cite{QS82}. The method requires a program and a property as input and then it extracts a model from the program. The method then computes and returns either "correct" when the specification
is satisfied by the program, or "incorrect" when the program does not satisfy its specification. In the case of incorrect answer, the method can explain the reason by giving a counter-example. A state in the model contains relevant information about the program. Alongside all the states of the system, the model depicts the
transitions, i.e.\ how to move from one state to another state. Every behaviour of the system is represented as a succession of
transitions, starting from some initial states. States and transitions together describe the \emph{operational
  semantics}, that is, how every step of the system takes place in the
model. The number of states and transitions can be finite or infinite Model-checking aims to explore the state-space entirely from some initial states. However, when the state-space is of large size. It grows in-fact
exponentially with the number of parameters or the size of their
domain. Therefore, there have been several methods to deal with the
state-space explosion problem.
%\begin{figure}[h]
%{\noindent\centering %
%  \includegraphics[trim=4cm 4cm 1.5cm 2cm,clip,scale = 0.3]{img/modelchecking.pdf}%
%  \par%
%}%
%\caption{Example of symbolic representation where the right part is a concrete reachable state-space and the left part is abstract state-space using symbolic representation}
%\label{symbolicabs}
%\end{figure}
\vspace{1cm}
\begin{figure}[h]
  \centering
  \tikzinput{img/symbolic-representations}    
  \vspace{0.3cm}
  \caption{Symbolic Representation}      
\label{symbolicabs}
\end{figure}
\vspace{1cm}
The choice of which transition to pick during the exploration can be
crucial for the efficiency of the procedure. In some cases, exploring all orderings of events is not necessary because some states can be re-visited. \emph{Partial order} techniques aim at detecting and avoiding
redundant situations, while retaining important dependencies among
actions. They however do not reduce the state-space. The main approach called \emph{symbolic
  representation}  to solve the state-space explosion problem is to avoid representing concretely all states of the system. the approach group several states together form sets of states and represent them by single states described in figure \ref{symbolicabs}. The grouping process is performed by \emph{dropping} irrelevant
details (as opposed to disregarding them) based on properties that we want to verify. Figure \ref{symbolicmodelchecking} show the architecture of symbolic model checking in which it is sound to prove safety of the abstract model in order to imply
safety for the original system, since all the behaviours of the latter
are represented in the former. %
%
The challenge is to find over-approximations that do not introduce
behaviours that could turn out to be bad. Indeed, the method would
return that the property is not satisfied and we would not know
whether it comes from the approximation or from the concrete system
itself. %

%\begin{figure}
%{\noindent\centering %
%  \includegraphics[trim=0cm 6cm 2cm 2cm,clip,scale = 0.25]{img/badstate.pdf}%
%  \par%
%}%
%\caption{Symbolic model checking architecture }	
%\label{symbolicmodelchecking}
%\end{figure}


\vspace{1cm}
\begin{figure}[h]
  \centering
  \tikzinput{img/approximations} 
  \vspace{0.3cm}
\caption{Symbolic model checking architecture }	
\label{symbolicmodelchecking}
\end{figure}
\vspace{1cm}

To palliate to the imprecision caused by a too coarse
over-approximation, it is possible to analyze the returned
counter-example and find the origin of the problem. If it turns out to
be a real concrete example, the method has in fact found a bug, and
the property is surely not satisfied. Otherwise, the counter-example
comes from the approximation, that is, there is a step in the sequence
of events leading to that counter-example which is not performed by
the original system but only by the abstract model. The approximation
is be refined by discarding this step and the method should be run
anew.

Nevertheless, finding suitable over-approximations is a challenge on
its own. %
This thesis now revolves around the following problem statement.
%
%\begin{statement}
%  {\bf Safety}: %
%  {\it Given a specification and an (over-)approximation,\\does the
%    abstract system reach a bad configuration?}
%\end{statement}
%
