%% ====================================================================
\chapter{Model Checking}
\label{section:model:checking}
\index{Model Checking}%
\index{Verification Methods!Model Checking}%
%% ====================================================================
%

The approach that we focus on this thesis is
\emph{model-checking}.
%% ********************************************************************
\KW{Automation}%
\index{Automation}%
%% ********************************************************************
%This method will try to verify whether a model of the program
%satisfies its specification.
%\bjcom{It does not really work to have a short first paragraph like this. It
%  is better to let the first paragraph flow. E.g., ``The approach ... . This approach was introduce ... Model checking aims to check whether a model of a rogram satisfies ..   As input, it requires ....   }
%\bjcom{After this, say that models are typically transition systems, and
%  explain. You must also say how properties are given. You need not say
%  much about that, but say that the most common form is to give an invariant,
%  or (equivalently) a set of bad states}
This approach was introduced by Emerson and Clarke~\cite{CE82} and by Queille and Sifakis~\cite{QS82}. 
 Model checking aims to check whether a model of a program satisfies its specification. As input, the method requires a model of the system under
consideration and a specification. Models are typically transition systems consisting of states and transitions between states. Whereas the specification contains safety requirements 
The method then computes and returns either "correct" when the specification is satisfied by the program, or "incorrect" when the program does not satisfy its specification. In the case of incorrect answer, the method can explain the reason by giving a counter-example. A state in the model contains relevant information about the program.
%\bjcom{Before writing this, you must introduce ``transition systems'', otherwise the reader did not see what ``state'' means. See, e.g., the thesis by To}
Alongside all the states of the system, the model depicts the
transitions, i.e.\ how to move from one state to another state. Every behaviour of the system is represented as a succession of transitions, starting from some initial states. States and transitions together describe the \emph{operational
  semantics}, that is, how steps of the system take place in the model.
%\bjcom{``how every...'' is strange wording}
The number of states and transitions can be finite or infinite.
%\bjcom{Better to write that initial approaches were for finite (explain), and that one direction of work (since 90's) has focused on state-space explosion,one on infinite}
Model-checking aims to explore the state-space entirely from some initial states. However, when the state-space is of large size. It grows in-fact
exponentially with the number of parameters or the size of their
domain. Therefore, there have been several methods to address with the
state-space explosion problem.

                   
There are several techniques addressing the state-space explosion problem.
Based on the fact that, in some cases, exploring all orderings of events is not necessary because some states can be re-visited. Therefore, \emph{Partial order} techniques aim at detecting and avoiding
redundant situations, while retaining important dependencies among
actions. The main approach to solve the state-space explosion problem is
called \emph{symbolic
   representation}. It avoid representing concretely all states of the system. The approach is performed by designing a symbolic representation of sets of states.
   %abstract states so that each abstract state could represent a set of concrete states.
% \bjcom{Often, one do not have clearly identifiable abstract states. Rather one has a symbolic representation of sets of states (then you do not need to talk about ``abstract'' and ``concrete'' states)}
This designing process is done by \emph{dropping} irrelevant details based on properties that we want to verify. 
As an example, consider a switch with two positions: {\tt up} and {\tt down}, and a counter that indicates how many times the light was turned on. Initially, its position is {\tt down}, the light is {\tt off} and the counter is $\tt 0$. When the switch is shifted up, the light is turned on, and the counter is incremented by $\tt 1$. When we shift the switch down, the light is turned off and the counter is reset to $\tt 0$ if it had reached its maximum value. We want to verify that the switch can not be up and the light is off at the same time. If we keep all the information of the system, then, a state consists of the position of the switch, the status of the light and the value of the counter, we would have $\tt (2*2*n)$ states where $\tt n$ is the maximum value of counter. If $\tt n$ is $\tt 1000000$ then we may end up to four million states.  However, it is obvious that the counter is not needed to verify the property, so we could ignore it. %\bjcom{Break the sentence here}
 Then a state contains only the position and status of the switch and the light denoted as $\tt [p,s]$ where $\tt p$ is the position and $\tt s$ is the state of the light. The system using the symbolic representation moves from  [{\tt down;off}]  to  [{\tt up;on}]  and conversely from  [{\tt up;on}]  to  [{\tt down;off}]. We see that the state-space exploration never visits a state that belongs to the set labeled by  [{\tt down;on}]  therefore the system is safe. The switch example is of course simple and does not reflect the complexity of todayâ€™s software. Symbolic representations are of crucial help to combat the state-space explosion, accelerate the algorithms and get them to terminate in a reasonable amount of time
\bjcom{The example is not really showing ``symbolic approach'', since you simply
  drop a variable. It would be better if you had an example, where you need
  to find a symbolic representation (e.g., ``odd''  ``even'', or so. You could
  maybe (just a possible idea) add a transition to a failure state if the
  counter satisfies some copmlex formula that can be true only when it is
  (say) even, and then introduce an abstraction for ``even/odd''. In that
  case you can illustrate better Symbolic technique, and overapproximation,
  and to check for saftey properties}


The challenge is to find over-approximations that do not introduce
behaviours that could turn out to be bad. Indeed, the method would
return that the property is not satisfied and we would not know
whether it comes from the approximation or from the concrete system
itself.
\bjcom{This last sentence was hard to understand. Maybe with a better example
  (see above) you can be more concrete, and it is easier to express what
  you want to say}% 
                  
\bjcom{It seems here that you want to illustrate counter-example-guided
  refinement. Then you should start by introducing the name of this method
  and its purpose. You can then explain it better. One way is to use the
  (improvement) of the above example. You can, e.g., say that if we would
  start with an overapproximation that ignores the counter, we get a false
  positive, and that one needs to refine the symbolic representation to
  avoid it}

To palliate \bjcom{Not a good word} to the imprecision caused by a too coarse
over-approximation, it is possible to analyze the returned
counter-example and find the origin of the problem. If it turns out to
be a real concrete example, the method has in fact found a bug, and
the property is surely not satisfied. Otherwise, the counter-example
comes from the approximation, that is, there is a step in the sequence
of events leading to that counter-example which is not performed by
the original system but only by the abstract model. The approximation
is be refined by discarding this step and the method should be run
anew.

Nevertheless, finding suitable over-approximations is a challenge on
its own. %
This thesis now revolves around the following problem statement.

\bjcom{Here you must continue. You can simply list the challenges that
  you address for symbolic model checking. Since you already listed them
  in Section 1, you can be quite short here}
